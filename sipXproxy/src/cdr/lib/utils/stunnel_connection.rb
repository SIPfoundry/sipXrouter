#
# Copyright (C) 2007 Pingtel Corp., certain elements licensed under a Contributor Agreement.  
# Contributors retain copyright to elements licensed under a Contributor Agreement.
# Licensed to the User under the LGPL license.
#
##############################################################################

require 'tempfile'

require 'utils/call_resolver_configure'
require 'utils/configure'
require 'db/database_url'
require 'utils/exceptions'
require 'utils/utils'

# Attempts to open stunnel connections to all configured distributed machines.
class StunnelConnection
  
  attr_reader :log
  
  STUNNEL_EXEC = '/usr/sbin/stunnel'  

  def initialize(config)
    @config = config
    @log = config.log
    @pid = nil
  end
  
  def open
    # Open stunnel connection only if HA is enabled    
    return unless @config.ha?
    
    config_file = Tempfile.new('stunnel-config')    
    generate_stunnel_config_file(config_file)
    
    @pid = fork do
      exec(STUNNEL_EXEC, config_file.path) 
    end
    log.info("Stunnel started: #{@pid}")
  end
  
  def close
    return unless @pid
    Process.kill("TERM", @pid)
    Process.wait(@pid, Process::WNOHANG)
    log.info {"Stunnel terminated. Exit status #{$?.exitstatus}"}
  end
  
  def get_ca_file
    cse_ca = @config.cse_ca
    raise_exception("SIP_CALLRESOLVER_CSE_CA must specify CA certificate name.", ConfigException) unless cse_ca
    
    ca_file = File.join(@config.ssldir, 'authorities', cse_ca)
    
    # Move to check config phase
    # checking this here does not work well for testing....    
    #    if ! File.readable?(ca_file)
    #      err_msg = "CA file: #{ca_file} does not exist or is not readable."
    #      raise_exception(err_msg, ConfigException)
    #    end
    return ca_file
  end
  
  # Generate the stunnel configuration based on the call resolver configuration  
  def generate_stunnel_config_file(config_file)    
    config_file.puts "# This file was automatically generated by sipxcallresolver"
    config_file.puts "client = yes"
    config_file.puts "foreground = yes"
    
    ca_file = get_ca_file()    
    config_file.puts "CAfile = #{ca_file}"
    
    cert_file = File.join(@config.ssldir, 'ssl.crt')
    key_file = File.join(@config.ssldir, 'ssl.key')
    
    config_file.puts "cert = #{cert_file}"
    config_file.puts "key = #{key_file}"
    
    config_file.puts "verify = 2"
    config_file.puts "debug = #{@config.stunnel_debug}"
    
    log_file = File.join(@config.logdir, 'sipxstunnel.log')    
    config_file.puts "output = #{log_file}"
    
    pid_file = File.join(@config.logdir, 'sipxstunnel.pid')
    config_file.puts "pid = #{pid_file}"
    
    @config.cse_hosts.each_with_index do |cse_host, i|
      next if cse_host.local
      config_file.puts "\n[Postgres-#{i}]"
      config_file.puts "accept = #{cse_host.port}"
      config_file.puts "connect = #{cse_host.host}:#{@config.cse_connect_port}"
    end
    config_file.close()
    
    if log.debug?
      config_file.open()
      config_file.each_line() { |line| log.debug(line.chop) }
      config_file.close()
    end
  end
  
  def raise_exception(err_msg, klass = CallResolverException)
    Utils.raise_exception(err_msg, klass)
  end
end
